/* tslint:disable */
/* eslint-disable */
/**
 * Projector
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateOrganizationDto
 */
export interface CreateOrganizationDto {
    /**
     * 
     * @type {OrganizationData}
     * @memberof CreateOrganizationDto
     */
    'data': OrganizationData;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'accessCode': string;
}
/**
 * 
 * @export
 * @interface DisplayState
 */
export interface DisplayState {
    /**
     * 
     * @type {string}
     * @memberof DisplayState
     */
    'displayType': DisplayStateDisplayTypeEnum;
    /**
     * 
     * @type {TextUnitState}
     * @memberof DisplayState
     */
    'textState': TextUnitState;
    /**
     * 
     * @type {boolean}
     * @memberof DisplayState
     */
    'emptyDisplay': boolean;
    /**
     * 
     * @type {Organization}
     * @memberof DisplayState
     */
    'organization': Organization;
    /**
     * 
     * @type {TextUnitQueue}
     * @memberof DisplayState
     */
    'textUnitQueue': TextUnitQueue;
    /**
     * 
     * @type {UploadedFile}
     * @memberof DisplayState
     */
    'uploadedFile'?: UploadedFile | null;
}

export const DisplayStateDisplayTypeEnum = {
    Text: 'TEXT',
    Media: 'MEDIA',
    Hls: 'HLS'
} as const;

export type DisplayStateDisplayTypeEnum = typeof DisplayStateDisplayTypeEnum[keyof typeof DisplayStateDisplayTypeEnum];

/**
 * 
 * @export
 * @interface GetOrganizationDto
 */
export interface GetOrganizationDto {
    /**
     * 
     * @type {number}
     * @memberof GetOrganizationDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {OrganizationData}
     * @memberof GetOrganizationDto
     */
    'data': OrganizationData;
    /**
     * 
     * @type {string}
     * @memberof GetOrganizationDto
     */
    'accessCode': string;
}
/**
 * 
 * @export
 * @interface GetProjectorStateDto
 */
export interface GetProjectorStateDto {
    /**
     * 
     * @type {string}
     * @memberof GetProjectorStateDto
     */
    'displayType': GetProjectorStateDtoDisplayTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GetProjectorStateDto
     */
    'emptyDisplay': boolean;
    /**
     * 
     * @type {TextUnitState}
     * @memberof GetProjectorStateDto
     */
    'textState': TextUnitState;
    /**
     * 
     * @type {ProjectorSettingsConfigurationDto}
     * @memberof GetProjectorStateDto
     */
    'settings': ProjectorSettingsConfigurationDto;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetProjectorStateDto
     */
    'lines': Array<string>;
    /**
     * 
     * @type {UploadedFileDto}
     * @memberof GetProjectorStateDto
     */
    'uploadedFile': UploadedFileDto | null;
    /**
     * 
     * @type {number}
     * @memberof GetProjectorStateDto
     */
    'lastUpdateTime': number;
}

export const GetProjectorStateDtoDisplayTypeEnum = {
    Text: 'TEXT',
    Media: 'MEDIA',
    Hls: 'HLS'
} as const;

export type GetProjectorStateDtoDisplayTypeEnum = typeof GetProjectorStateDtoDisplayTypeEnum[keyof typeof GetProjectorStateDtoDisplayTypeEnum];

/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'accessCode': string;
}
/**
 * 
 * @export
 * @interface MovePageDto
 */
export interface MovePageDto {
    /**
     * 
     * @type {string}
     * @memberof MovePageDto
     */
    'direction': MovePageDtoDirectionEnum;
}

export const MovePageDtoDirectionEnum = {
    Next: 'NEXT',
    Previous: 'PREVIOUS'
} as const;

export type MovePageDtoDirectionEnum = typeof MovePageDtoDirectionEnum[keyof typeof MovePageDtoDirectionEnum];

/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {DisplayState}
     * @memberof Organization
     */
    'projectorState': DisplayState;
    /**
     * 
     * @type {Array<TextUnitQueue>}
     * @memberof Organization
     */
    'textUnitQueues': Array<TextUnitQueue>;
    /**
     * 
     * @type {Array<TextUnit>}
     * @memberof Organization
     */
    'textUnits': Array<TextUnit>;
    /**
     * 
     * @type {Array<TextUnitTag>}
     * @memberof Organization
     */
    'textUnitTags': Array<TextUnitTag>;
    /**
     * 
     * @type {Array<UploadedFile>}
     * @memberof Organization
     */
    'uploadedFiles': Array<UploadedFile>;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'accessCode': string;
    /**
     * 
     * @type {OrganizationData}
     * @memberof Organization
     */
    'data': OrganizationData;
}
/**
 * 
 * @export
 * @interface OrganizationData
 */
export interface OrganizationData {
    /**
     * 
     * @type {string}
     * @memberof OrganizationData
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ProjectorSettingsConfigurationDto
 */
export interface ProjectorSettingsConfigurationDto {
    /**
     * 
     * @type {string}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'backgroundColor': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'fontColor': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'fontFamily': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'fontSize': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'textAlign': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'letterSpacing': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'marginInline': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'marginBlock': string;
    /**
     * 
     * @type {string}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'paddingTop': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'charactersInLine': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'linesOnPage': number;
    /**
     * 
     * @type {string}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'textVertically': string;
    /**
     * 
     * @type {number}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'screenWidth': number;
    /**
     * 
     * @type {number}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'screenHeight': number;
    /**
     * 
     * @type {string}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'lineHeight': string;
    /**
     * 
     * @type {TextStrategy}
     * @memberof ProjectorSettingsConfigurationDto
     */
    'textStrategy': TextStrategy;
}


/**
 * 
 * @export
 * @interface QueueTextUnit
 */
export interface QueueTextUnit {
    /**
     * 
     * @type {number}
     * @memberof QueueTextUnit
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof QueueTextUnit
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface RenameUploadedFileDto
 */
export interface RenameUploadedFileDto {
    /**
     * 
     * @type {number}
     * @memberof RenameUploadedFileDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof RenameUploadedFileDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SetCurrentTextUnitDto
 */
export interface SetCurrentTextUnitDto {
    /**
     * 
     * @type {number}
     * @memberof SetCurrentTextUnitDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface SetCurrentTextUnitQueueDto
 */
export interface SetCurrentTextUnitQueueDto {
    /**
     * 
     * @type {number}
     * @memberof SetCurrentTextUnitQueueDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface SetCurrentUploadedFileDto
 */
export interface SetCurrentUploadedFileDto {
    /**
     * 
     * @type {string}
     * @memberof SetCurrentUploadedFileDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TextStrategy = {
    FixedLines: 'FIXED_LINES',
    Automatic: 'AUTOMATIC',
    ExampleText: 'EXAMPLE_TEXT'
} as const;

export type TextStrategy = typeof TextStrategy[keyof typeof TextStrategy];


/**
 * 
 * @export
 * @interface TextUnit
 */
export interface TextUnit {
    /**
     * 
     * @type {string}
     * @memberof TextUnit
     */
    'content': string;
    /**
     * 
     * @type {Organization}
     * @memberof TextUnit
     */
    'organization': Organization | null;
    /**
     * 
     * @type {number}
     * @memberof TextUnit
     */
    'organizationId': number | null;
    /**
     * 
     * @type {string}
     * @memberof TextUnit
     */
    'title': string;
    /**
     * 
     * @type {Array<TextUnitTag>}
     * @memberof TextUnit
     */
    'tags': Array<TextUnitTag>;
}
/**
 * 
 * @export
 * @interface TextUnitDto
 */
export interface TextUnitDto {
    /**
     * 
     * @type {number}
     * @memberof TextUnitDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TextUnitDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextUnitDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextUnitDto
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof TextUnitDto
     */
    'title': string;
    /**
     * 
     * @type {Array<TextUnitTagDto>}
     * @memberof TextUnitDto
     */
    'tags': Array<TextUnitTagDto>;
}
/**
 * 
 * @export
 * @interface TextUnitQueue
 */
export interface TextUnitQueue {
    /**
     * 
     * @type {string}
     * @memberof TextUnitQueue
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TextUnitQueue
     */
    'description': string;
    /**
     * 
     * @type {Organization}
     * @memberof TextUnitQueue
     */
    'organization': Organization;
    /**
     * 
     * @type {number}
     * @memberof TextUnitQueue
     */
    'organizationId': number | null;
    /**
     * 
     * @type {TextUnitQueueContent}
     * @memberof TextUnitQueue
     */
    'content': TextUnitQueueContent;
    /**
     * 
     * @type {DisplayState}
     * @memberof TextUnitQueue
     */
    'projectorState': DisplayState;
}
/**
 * 
 * @export
 * @interface TextUnitQueueContent
 */
export interface TextUnitQueueContent {
    /**
     * 
     * @type {Array<QueueTextUnit>}
     * @memberof TextUnitQueueContent
     */
    'textUnits': Array<QueueTextUnit>;
}
/**
 * 
 * @export
 * @interface TextUnitQueueDto
 */
export interface TextUnitQueueDto {
    /**
     * 
     * @type {number}
     * @memberof TextUnitQueueDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TextUnitQueueDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextUnitQueueDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextUnitQueueDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TextUnitQueueDto
     */
    'description'?: string;
    /**
     * 
     * @type {TextUnitQueueContent}
     * @memberof TextUnitQueueDto
     */
    'content': TextUnitQueueContent;
}
/**
 * 
 * @export
 * @interface TextUnitState
 */
export interface TextUnitState {
    /**
     * 
     * @type {number}
     * @memberof TextUnitState
     */
    'textUnitId': number;
    /**
     * 
     * @type {number}
     * @memberof TextUnitState
     */
    'textUnitPart': number;
    /**
     * 
     * @type {number}
     * @memberof TextUnitState
     */
    'textUnitPartPage': number;
}
/**
 * 
 * @export
 * @interface TextUnitTag
 */
export interface TextUnitTag {
    /**
     * 
     * @type {string}
     * @memberof TextUnitTag
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TextUnitTag
     */
    'description': string;
    /**
     * 
     * @type {Organization}
     * @memberof TextUnitTag
     */
    'organization': Organization | null;
    /**
     * 
     * @type {number}
     * @memberof TextUnitTag
     */
    'organizationId': number | null;
    /**
     * 
     * @type {Array<TextUnit>}
     * @memberof TextUnitTag
     */
    'textUnits': Array<TextUnit>;
}
/**
 * 
 * @export
 * @interface TextUnitTagDto
 */
export interface TextUnitTagDto {
    /**
     * 
     * @type {number}
     * @memberof TextUnitTagDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof TextUnitTagDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextUnitTagDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextUnitTagDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TextUnitTagDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface UpdateDisplayStateDto
 */
export interface UpdateDisplayStateDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateDisplayStateDto
     */
    'displayType'?: UpdateDisplayStateDtoDisplayTypeEnum;
    /**
     * 
     * @type {TextUnitState}
     * @memberof UpdateDisplayStateDto
     */
    'textState'?: TextUnitState;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateDisplayStateDto
     */
    'emptyDisplay'?: boolean;
}

export const UpdateDisplayStateDtoDisplayTypeEnum = {
    Text: 'TEXT',
    Media: 'MEDIA',
    Hls: 'HLS'
} as const;

export type UpdateDisplayStateDtoDisplayTypeEnum = typeof UpdateDisplayStateDtoDisplayTypeEnum[keyof typeof UpdateDisplayStateDtoDisplayTypeEnum];

/**
 * 
 * @export
 * @interface UploadedFile
 */
export interface UploadedFile {
    /**
     * 
     * @type {string}
     * @memberof UploadedFile
     */
    'mimeType': string;
    /**
     * 
     * @type {string}
     * @memberof UploadedFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UploadedFile
     */
    'url': string;
    /**
     * 
     * @type {Organization}
     * @memberof UploadedFile
     */
    'organization': Organization | null;
    /**
     * 
     * @type {number}
     * @memberof UploadedFile
     */
    'organizationId': number | null;
    /**
     * 
     * @type {number}
     * @memberof UploadedFile
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof UploadedFile
     */
    'previewUrl': string;
}
/**
 * 
 * @export
 * @interface UploadedFileDto
 */
export interface UploadedFileDto {
    /**
     * 
     * @type {number}
     * @memberof UploadedFileDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UploadedFileDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadedFileDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadedFileDto
     */
    'mimeType': string;
    /**
     * 
     * @type {string}
     * @memberof UploadedFileDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UploadedFileDto
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof UploadedFileDto
     */
    'size': number;
    /**
     * 
     * @type {string}
     * @memberof UploadedFileDto
     */
    'previewUrl': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGetProfile(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrganizationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGetProfile(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerGetProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGetProfile(options?: any): AxiosPromise<GetOrganizationDto> {
            return localVarFp.authControllerGetProfile(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: any): AxiosPromise<string> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerGetProfile(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerGetProfile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DisplayStateApi - axios parameter creator
 * @export
 */
export const DisplayStateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerGetDisplayState: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/display-state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MovePageDto} movePageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerMovePage: async (movePageDto: MovePageDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'movePageDto' is not null or undefined
            assertParamExists('displayStateControllerMovePage', 'movePageDto', movePageDto)
            const localVarPath = `/api/display-state/move-page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(movePageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateDisplayStateDto} updateDisplayStateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerUpdateDisplayState: async (updateDisplayStateDto: UpdateDisplayStateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDisplayStateDto' is not null or undefined
            assertParamExists('displayStateControllerUpdateDisplayState', 'updateDisplayStateDto', updateDisplayStateDto)
            const localVarPath = `/api/display-state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDisplayStateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisplayStateApi - functional programming interface
 * @export
 */
export const DisplayStateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisplayStateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayStateControllerGetDisplayState(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisplayState>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayStateControllerGetDisplayState(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisplayStateApi.displayStateControllerGetDisplayState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MovePageDto} movePageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayStateControllerMovePage(movePageDto: MovePageDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayStateControllerMovePage(movePageDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisplayStateApi.displayStateControllerMovePage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateDisplayStateDto} updateDisplayStateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayStateControllerUpdateDisplayState(updateDisplayStateDto: UpdateDisplayStateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayStateControllerUpdateDisplayState(updateDisplayStateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisplayStateApi.displayStateControllerUpdateDisplayState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DisplayStateApi - factory interface
 * @export
 */
export const DisplayStateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisplayStateApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerGetDisplayState(options?: any): AxiosPromise<DisplayState> {
            return localVarFp.displayStateControllerGetDisplayState(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MovePageDto} movePageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerMovePage(movePageDto: MovePageDto, options?: any): AxiosPromise<void> {
            return localVarFp.displayStateControllerMovePage(movePageDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateDisplayStateDto} updateDisplayStateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerUpdateDisplayState(updateDisplayStateDto: UpdateDisplayStateDto, options?: any): AxiosPromise<void> {
            return localVarFp.displayStateControllerUpdateDisplayState(updateDisplayStateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisplayStateApi - object-oriented interface
 * @export
 * @class DisplayStateApi
 * @extends {BaseAPI}
 */
export class DisplayStateApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayStateApi
     */
    public displayStateControllerGetDisplayState(options?: RawAxiosRequestConfig) {
        return DisplayStateApiFp(this.configuration).displayStateControllerGetDisplayState(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MovePageDto} movePageDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayStateApi
     */
    public displayStateControllerMovePage(movePageDto: MovePageDto, options?: RawAxiosRequestConfig) {
        return DisplayStateApiFp(this.configuration).displayStateControllerMovePage(movePageDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateDisplayStateDto} updateDisplayStateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayStateApi
     */
    public displayStateControllerUpdateDisplayState(updateDisplayStateDto: UpdateDisplayStateDto, options?: RawAxiosRequestConfig) {
        return DisplayStateApiFp(this.configuration).displayStateControllerUpdateDisplayState(updateDisplayStateDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerCreate: async (createOrganizationDto: CreateOrganizationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationDto' is not null or undefined
            assertParamExists('organizationsControllerCreate', 'createOrganizationDto', createOrganizationDto)
            const localVarPath = `/api/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('organizationsControllerFindOne', 'id', id)
            const localVarPath = `/api/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerCreate(createOrganizationDto: CreateOrganizationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerCreate(createOrganizationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.organizationsControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetOrganizationDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.organizationsControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationsControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrganizationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationsControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.organizationsControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerCreate(createOrganizationDto: CreateOrganizationDto, options?: any): AxiosPromise<void> {
            return localVarFp.organizationsControllerCreate(createOrganizationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerFindAll(options?: any): AxiosPromise<Array<GetOrganizationDto>> {
            return localVarFp.organizationsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationsControllerFindOne(id: string, options?: any): AxiosPromise<GetOrganizationDto> {
            return localVarFp.organizationsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @param {CreateOrganizationDto} createOrganizationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerCreate(createOrganizationDto: CreateOrganizationDto, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerCreate(createOrganizationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerFindAll(options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationsControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectorApi - axios parameter creator
 * @export
 */
export const ProjectorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorControllerGetLastUpdateTimestamp: async (organizationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('projectorControllerGetLastUpdateTimestamp', 'organizationId', organizationId)
            const localVarPath = `/api/projector/last-update/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorControllerGetProjectorState: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projector`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorControllerGetProjectorStateByOrganizationId: async (organizationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('projectorControllerGetProjectorStateByOrganizationId', 'organizationId', organizationId)
            const localVarPath = `/api/projector/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectorApi - functional programming interface
 * @export
 */
export const ProjectorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectorControllerGetLastUpdateTimestamp(organizationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectorControllerGetLastUpdateTimestamp(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectorApi.projectorControllerGetLastUpdateTimestamp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectorControllerGetProjectorState(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectorStateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectorControllerGetProjectorState(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectorApi.projectorControllerGetProjectorState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectorControllerGetProjectorStateByOrganizationId(organizationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectorStateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectorControllerGetProjectorStateByOrganizationId(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectorApi.projectorControllerGetProjectorStateByOrganizationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectorApi - factory interface
 * @export
 */
export const ProjectorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectorApiFp(configuration)
    return {
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorControllerGetLastUpdateTimestamp(organizationId: number, options?: any): AxiosPromise<number> {
            return localVarFp.projectorControllerGetLastUpdateTimestamp(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorControllerGetProjectorState(options?: any): AxiosPromise<GetProjectorStateDto> {
            return localVarFp.projectorControllerGetProjectorState(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorControllerGetProjectorStateByOrganizationId(organizationId: number, options?: any): AxiosPromise<GetProjectorStateDto> {
            return localVarFp.projectorControllerGetProjectorStateByOrganizationId(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectorApi - object-oriented interface
 * @export
 * @class ProjectorApi
 * @extends {BaseAPI}
 */
export class ProjectorApi extends BaseAPI {
    /**
     * 
     * @param {number} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectorApi
     */
    public projectorControllerGetLastUpdateTimestamp(organizationId: number, options?: RawAxiosRequestConfig) {
        return ProjectorApiFp(this.configuration).projectorControllerGetLastUpdateTimestamp(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectorApi
     */
    public projectorControllerGetProjectorState(options?: RawAxiosRequestConfig) {
        return ProjectorApiFp(this.configuration).projectorControllerGetProjectorState(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectorApi
     */
    public projectorControllerGetProjectorStateByOrganizationId(organizationId: number, options?: RawAxiosRequestConfig) {
        return ProjectorApiFp(this.configuration).projectorControllerGetProjectorStateByOrganizationId(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectorSettingsApi - axios parameter creator
 * @export
 */
export const ProjectorSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerGetSetting: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projector-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerGetSettingsByOrganizationId: async (organizationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('projectorSettingsControllerGetSettingsByOrganizationId', 'organizationId', organizationId)
            const localVarPath = `/api/projector-settings/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ProjectorSettingsConfigurationDto} projectorSettingsConfigurationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerUpdate: async (projectorSettingsConfigurationDto: ProjectorSettingsConfigurationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectorSettingsConfigurationDto' is not null or undefined
            assertParamExists('projectorSettingsControllerUpdate', 'projectorSettingsConfigurationDto', projectorSettingsConfigurationDto)
            const localVarPath = `/api/projector-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectorSettingsConfigurationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectorSettingsApi - functional programming interface
 * @export
 */
export const ProjectorSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectorSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectorSettingsControllerGetSetting(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectorSettingsConfigurationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectorSettingsControllerGetSetting(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectorSettingsApi.projectorSettingsControllerGetSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectorSettingsControllerGetSettingsByOrganizationId(organizationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectorSettingsConfigurationDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectorSettingsControllerGetSettingsByOrganizationId(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectorSettingsApi.projectorSettingsControllerGetSettingsByOrganizationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ProjectorSettingsConfigurationDto} projectorSettingsConfigurationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectorSettingsControllerUpdate(projectorSettingsConfigurationDto: ProjectorSettingsConfigurationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectorSettingsControllerUpdate(projectorSettingsConfigurationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectorSettingsApi.projectorSettingsControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectorSettingsApi - factory interface
 * @export
 */
export const ProjectorSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectorSettingsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerGetSetting(options?: any): AxiosPromise<ProjectorSettingsConfigurationDto> {
            return localVarFp.projectorSettingsControllerGetSetting(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerGetSettingsByOrganizationId(organizationId: number, options?: any): AxiosPromise<ProjectorSettingsConfigurationDto> {
            return localVarFp.projectorSettingsControllerGetSettingsByOrganizationId(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ProjectorSettingsConfigurationDto} projectorSettingsConfigurationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerUpdate(projectorSettingsConfigurationDto: ProjectorSettingsConfigurationDto, options?: any): AxiosPromise<void> {
            return localVarFp.projectorSettingsControllerUpdate(projectorSettingsConfigurationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectorSettingsApi - object-oriented interface
 * @export
 * @class ProjectorSettingsApi
 * @extends {BaseAPI}
 */
export class ProjectorSettingsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectorSettingsApi
     */
    public projectorSettingsControllerGetSetting(options?: RawAxiosRequestConfig) {
        return ProjectorSettingsApiFp(this.configuration).projectorSettingsControllerGetSetting(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectorSettingsApi
     */
    public projectorSettingsControllerGetSettingsByOrganizationId(organizationId: number, options?: RawAxiosRequestConfig) {
        return ProjectorSettingsApiFp(this.configuration).projectorSettingsControllerGetSettingsByOrganizationId(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ProjectorSettingsConfigurationDto} projectorSettingsConfigurationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectorSettingsApi
     */
    public projectorSettingsControllerUpdate(projectorSettingsConfigurationDto: ProjectorSettingsConfigurationDto, options?: RawAxiosRequestConfig) {
        return ProjectorSettingsApiFp(this.configuration).projectorSettingsControllerUpdate(projectorSettingsConfigurationDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextUnitQueuesApi - axios parameter creator
 * @export
 */
export const TextUnitQueuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TextUnitQueueDto} textUnitQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerCreate: async (textUnitQueueDto: TextUnitQueueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textUnitQueueDto' is not null or undefined
            assertParamExists('textUnitQueuesControllerCreate', 'textUnitQueueDto', textUnitQueueDto)
            const localVarPath = `/api/text-unit-queues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textUnitQueueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/text-unit-queues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textUnitQueuesControllerFindOne', 'id', id)
            const localVarPath = `/api/text-unit-queues/by-id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerGetCurrentTextUnitQueue: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/text-unit-queues/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textUnitQueuesControllerRemove', 'id', id)
            const localVarPath = `/api/text-unit-queues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetCurrentTextUnitQueueDto} setCurrentTextUnitQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerSetCurrentTextUnitQueue: async (setCurrentTextUnitQueueDto: SetCurrentTextUnitQueueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setCurrentTextUnitQueueDto' is not null or undefined
            assertParamExists('textUnitQueuesControllerSetCurrentTextUnitQueue', 'setCurrentTextUnitQueueDto', setCurrentTextUnitQueueDto)
            const localVarPath = `/api/text-unit-queues/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setCurrentTextUnitQueueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TextUnitQueueDto} textUnitQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerUpdate: async (textUnitQueueDto: TextUnitQueueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textUnitQueueDto' is not null or undefined
            assertParamExists('textUnitQueuesControllerUpdate', 'textUnitQueueDto', textUnitQueueDto)
            const localVarPath = `/api/text-unit-queues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textUnitQueueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextUnitQueuesApi - functional programming interface
 * @export
 */
export const TextUnitQueuesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextUnitQueuesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TextUnitQueueDto} textUnitQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitQueuesControllerCreate(textUnitQueueDto: TextUnitQueueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextUnitQueue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitQueuesControllerCreate(textUnitQueueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitQueuesApi.textUnitQueuesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitQueuesControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TextUnitQueueDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitQueuesControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitQueuesApi.textUnitQueuesControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitQueuesControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextUnitQueueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitQueuesControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitQueuesApi.textUnitQueuesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitQueuesControllerGetCurrentTextUnitQueue(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextUnitQueueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitQueuesControllerGetCurrentTextUnitQueue(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitQueuesApi.textUnitQueuesControllerGetCurrentTextUnitQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitQueuesControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitQueuesControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitQueuesApi.textUnitQueuesControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetCurrentTextUnitQueueDto} setCurrentTextUnitQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitQueuesControllerSetCurrentTextUnitQueue(setCurrentTextUnitQueueDto: SetCurrentTextUnitQueueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitQueuesControllerSetCurrentTextUnitQueue(setCurrentTextUnitQueueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitQueuesApi.textUnitQueuesControllerSetCurrentTextUnitQueue']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TextUnitQueueDto} textUnitQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitQueuesControllerUpdate(textUnitQueueDto: TextUnitQueueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitQueuesControllerUpdate(textUnitQueueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitQueuesApi.textUnitQueuesControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextUnitQueuesApi - factory interface
 * @export
 */
export const TextUnitQueuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextUnitQueuesApiFp(configuration)
    return {
        /**
         * 
         * @param {TextUnitQueueDto} textUnitQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerCreate(textUnitQueueDto: TextUnitQueueDto, options?: any): AxiosPromise<TextUnitQueue> {
            return localVarFp.textUnitQueuesControllerCreate(textUnitQueueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerFindAll(options?: any): AxiosPromise<Array<TextUnitQueueDto>> {
            return localVarFp.textUnitQueuesControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerFindOne(id: string, options?: any): AxiosPromise<TextUnitQueueDto> {
            return localVarFp.textUnitQueuesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerGetCurrentTextUnitQueue(options?: any): AxiosPromise<TextUnitQueueDto> {
            return localVarFp.textUnitQueuesControllerGetCurrentTextUnitQueue(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.textUnitQueuesControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetCurrentTextUnitQueueDto} setCurrentTextUnitQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerSetCurrentTextUnitQueue(setCurrentTextUnitQueueDto: SetCurrentTextUnitQueueDto, options?: any): AxiosPromise<void> {
            return localVarFp.textUnitQueuesControllerSetCurrentTextUnitQueue(setCurrentTextUnitQueueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TextUnitQueueDto} textUnitQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitQueuesControllerUpdate(textUnitQueueDto: TextUnitQueueDto, options?: any): AxiosPromise<void> {
            return localVarFp.textUnitQueuesControllerUpdate(textUnitQueueDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextUnitQueuesApi - object-oriented interface
 * @export
 * @class TextUnitQueuesApi
 * @extends {BaseAPI}
 */
export class TextUnitQueuesApi extends BaseAPI {
    /**
     * 
     * @param {TextUnitQueueDto} textUnitQueueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitQueuesApi
     */
    public textUnitQueuesControllerCreate(textUnitQueueDto: TextUnitQueueDto, options?: RawAxiosRequestConfig) {
        return TextUnitQueuesApiFp(this.configuration).textUnitQueuesControllerCreate(textUnitQueueDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitQueuesApi
     */
    public textUnitQueuesControllerFindAll(options?: RawAxiosRequestConfig) {
        return TextUnitQueuesApiFp(this.configuration).textUnitQueuesControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitQueuesApi
     */
    public textUnitQueuesControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return TextUnitQueuesApiFp(this.configuration).textUnitQueuesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitQueuesApi
     */
    public textUnitQueuesControllerGetCurrentTextUnitQueue(options?: RawAxiosRequestConfig) {
        return TextUnitQueuesApiFp(this.configuration).textUnitQueuesControllerGetCurrentTextUnitQueue(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitQueuesApi
     */
    public textUnitQueuesControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return TextUnitQueuesApiFp(this.configuration).textUnitQueuesControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetCurrentTextUnitQueueDto} setCurrentTextUnitQueueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitQueuesApi
     */
    public textUnitQueuesControllerSetCurrentTextUnitQueue(setCurrentTextUnitQueueDto: SetCurrentTextUnitQueueDto, options?: RawAxiosRequestConfig) {
        return TextUnitQueuesApiFp(this.configuration).textUnitQueuesControllerSetCurrentTextUnitQueue(setCurrentTextUnitQueueDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TextUnitQueueDto} textUnitQueueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitQueuesApi
     */
    public textUnitQueuesControllerUpdate(textUnitQueueDto: TextUnitQueueDto, options?: RawAxiosRequestConfig) {
        return TextUnitQueuesApiFp(this.configuration).textUnitQueuesControllerUpdate(textUnitQueueDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextUnitTagApi - axios parameter creator
 * @export
 */
export const TextUnitTagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TextUnitTagDto} textUnitTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerCreate: async (textUnitTagDto: TextUnitTagDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textUnitTagDto' is not null or undefined
            assertParamExists('textUnitTagControllerCreate', 'textUnitTagDto', textUnitTagDto)
            const localVarPath = `/api/text-unit-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textUnitTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/text-unit-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textUnitTagControllerFindOne', 'id', id)
            const localVarPath = `/api/text-unit-tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textUnitTagControllerRemove', 'id', id)
            const localVarPath = `/api/text-unit-tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {TextUnitTagDto} textUnitTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerUpdate: async (id: string, textUnitTagDto: TextUnitTagDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textUnitTagControllerUpdate', 'id', id)
            // verify required parameter 'textUnitTagDto' is not null or undefined
            assertParamExists('textUnitTagControllerUpdate', 'textUnitTagDto', textUnitTagDto)
            const localVarPath = `/api/text-unit-tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textUnitTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextUnitTagApi - functional programming interface
 * @export
 */
export const TextUnitTagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextUnitTagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TextUnitTagDto} textUnitTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitTagControllerCreate(textUnitTagDto: TextUnitTagDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextUnitTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitTagControllerCreate(textUnitTagDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitTagApi.textUnitTagControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitTagControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TextUnitTagDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitTagControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitTagApi.textUnitTagControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitTagControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextUnitTagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitTagControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitTagApi.textUnitTagControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitTagControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitTagControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitTagApi.textUnitTagControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {TextUnitTagDto} textUnitTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitTagControllerUpdate(id: string, textUnitTagDto: TextUnitTagDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextUnitTag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitTagControllerUpdate(id, textUnitTagDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitTagApi.textUnitTagControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextUnitTagApi - factory interface
 * @export
 */
export const TextUnitTagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextUnitTagApiFp(configuration)
    return {
        /**
         * 
         * @param {TextUnitTagDto} textUnitTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerCreate(textUnitTagDto: TextUnitTagDto, options?: any): AxiosPromise<TextUnitTag> {
            return localVarFp.textUnitTagControllerCreate(textUnitTagDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerFindAll(options?: any): AxiosPromise<Array<TextUnitTagDto>> {
            return localVarFp.textUnitTagControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerFindOne(id: string, options?: any): AxiosPromise<TextUnitTagDto> {
            return localVarFp.textUnitTagControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.textUnitTagControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {TextUnitTagDto} textUnitTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerUpdate(id: string, textUnitTagDto: TextUnitTagDto, options?: any): AxiosPromise<TextUnitTag> {
            return localVarFp.textUnitTagControllerUpdate(id, textUnitTagDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextUnitTagApi - object-oriented interface
 * @export
 * @class TextUnitTagApi
 * @extends {BaseAPI}
 */
export class TextUnitTagApi extends BaseAPI {
    /**
     * 
     * @param {TextUnitTagDto} textUnitTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitTagApi
     */
    public textUnitTagControllerCreate(textUnitTagDto: TextUnitTagDto, options?: RawAxiosRequestConfig) {
        return TextUnitTagApiFp(this.configuration).textUnitTagControllerCreate(textUnitTagDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitTagApi
     */
    public textUnitTagControllerFindAll(options?: RawAxiosRequestConfig) {
        return TextUnitTagApiFp(this.configuration).textUnitTagControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitTagApi
     */
    public textUnitTagControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return TextUnitTagApiFp(this.configuration).textUnitTagControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitTagApi
     */
    public textUnitTagControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return TextUnitTagApiFp(this.configuration).textUnitTagControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {TextUnitTagDto} textUnitTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitTagApi
     */
    public textUnitTagControllerUpdate(id: string, textUnitTagDto: TextUnitTagDto, options?: RawAxiosRequestConfig) {
        return TextUnitTagApiFp(this.configuration).textUnitTagControllerUpdate(id, textUnitTagDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextUnitsApi - axios parameter creator
 * @export
 */
export const TextUnitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TextUnitDto} textUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerCreate: async (textUnitDto: TextUnitDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textUnitDto' is not null or undefined
            assertParamExists('textUnitControllerCreate', 'textUnitDto', textUnitDto)
            const localVarPath = `/api/text-units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textUnitDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/text-units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textUnitControllerFindOne', 'id', id)
            const localVarPath = `/api/text-units/by-id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerGetCurrentTextUnit: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/text-units/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textUnitControllerRemove', 'id', id)
            const localVarPath = `/api/text-units/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetCurrentTextUnitDto} setCurrentTextUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerSetCurrentTextUnit: async (setCurrentTextUnitDto: SetCurrentTextUnitDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setCurrentTextUnitDto' is not null or undefined
            assertParamExists('textUnitControllerSetCurrentTextUnit', 'setCurrentTextUnitDto', setCurrentTextUnitDto)
            const localVarPath = `/api/text-units/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setCurrentTextUnitDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TextUnitDto} textUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerUpdate: async (textUnitDto: TextUnitDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textUnitDto' is not null or undefined
            assertParamExists('textUnitControllerUpdate', 'textUnitDto', textUnitDto)
            const localVarPath = `/api/text-units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textUnitDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextUnitsApi - functional programming interface
 * @export
 */
export const TextUnitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextUnitsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {TextUnitDto} textUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitControllerCreate(textUnitDto: TextUnitDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitControllerCreate(textUnitDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitsApi.textUnitControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TextUnitDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitsApi.textUnitControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextUnitDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitsApi.textUnitControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitControllerGetCurrentTextUnit(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextUnitDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitControllerGetCurrentTextUnit(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitsApi.textUnitControllerGetCurrentTextUnit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitsApi.textUnitControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetCurrentTextUnitDto} setCurrentTextUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitControllerSetCurrentTextUnit(setCurrentTextUnitDto: SetCurrentTextUnitDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitControllerSetCurrentTextUnit(setCurrentTextUnitDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitsApi.textUnitControllerSetCurrentTextUnit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TextUnitDto} textUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitControllerUpdate(textUnitDto: TextUnitDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitControllerUpdate(textUnitDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitsApi.textUnitControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextUnitsApi - factory interface
 * @export
 */
export const TextUnitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextUnitsApiFp(configuration)
    return {
        /**
         * 
         * @param {TextUnitDto} textUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerCreate(textUnitDto: TextUnitDto, options?: any): AxiosPromise<void> {
            return localVarFp.textUnitControllerCreate(textUnitDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerFindAll(options?: any): AxiosPromise<Array<TextUnitDto>> {
            return localVarFp.textUnitControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerFindOne(id: string, options?: any): AxiosPromise<TextUnitDto> {
            return localVarFp.textUnitControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerGetCurrentTextUnit(options?: any): AxiosPromise<TextUnitDto> {
            return localVarFp.textUnitControllerGetCurrentTextUnit(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.textUnitControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetCurrentTextUnitDto} setCurrentTextUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerSetCurrentTextUnit(setCurrentTextUnitDto: SetCurrentTextUnitDto, options?: any): AxiosPromise<void> {
            return localVarFp.textUnitControllerSetCurrentTextUnit(setCurrentTextUnitDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TextUnitDto} textUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerUpdate(textUnitDto: TextUnitDto, options?: any): AxiosPromise<void> {
            return localVarFp.textUnitControllerUpdate(textUnitDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextUnitsApi - object-oriented interface
 * @export
 * @class TextUnitsApi
 * @extends {BaseAPI}
 */
export class TextUnitsApi extends BaseAPI {
    /**
     * 
     * @param {TextUnitDto} textUnitDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitsApi
     */
    public textUnitControllerCreate(textUnitDto: TextUnitDto, options?: RawAxiosRequestConfig) {
        return TextUnitsApiFp(this.configuration).textUnitControllerCreate(textUnitDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitsApi
     */
    public textUnitControllerFindAll(options?: RawAxiosRequestConfig) {
        return TextUnitsApiFp(this.configuration).textUnitControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitsApi
     */
    public textUnitControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return TextUnitsApiFp(this.configuration).textUnitControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitsApi
     */
    public textUnitControllerGetCurrentTextUnit(options?: RawAxiosRequestConfig) {
        return TextUnitsApiFp(this.configuration).textUnitControllerGetCurrentTextUnit(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitsApi
     */
    public textUnitControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return TextUnitsApiFp(this.configuration).textUnitControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetCurrentTextUnitDto} setCurrentTextUnitDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitsApi
     */
    public textUnitControllerSetCurrentTextUnit(setCurrentTextUnitDto: SetCurrentTextUnitDto, options?: RawAxiosRequestConfig) {
        return TextUnitsApiFp(this.configuration).textUnitControllerSetCurrentTextUnit(setCurrentTextUnitDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TextUnitDto} textUnitDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitsApi
     */
    public textUnitControllerUpdate(textUnitDto: TextUnitDto, options?: RawAxiosRequestConfig) {
        return TextUnitsApiFp(this.configuration).textUnitControllerUpdate(textUnitDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadedFilesApi - axios parameter creator
 * @export
 */
export const UploadedFilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerGetCurrentFileForOrganization: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/uploaded-files/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerGetFilesForOrganization: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/uploaded-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerGetStreamManifest: async (organizationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('uploadedFilesControllerGetStreamManifest', 'organizationId', organizationId)
            const localVarPath = `/api/uploaded-files/stream-manifest/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadedFilesControllerRemove', 'id', id)
            const localVarPath = `/api/uploaded-files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RenameUploadedFileDto} renameUploadedFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerRenameFile: async (renameUploadedFileDto: RenameUploadedFileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'renameUploadedFileDto' is not null or undefined
            assertParamExists('uploadedFilesControllerRenameFile', 'renameUploadedFileDto', renameUploadedFileDto)
            const localVarPath = `/api/uploaded-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(renameUploadedFileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SetCurrentUploadedFileDto} setCurrentUploadedFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerSetCurrentUploadedFile: async (setCurrentUploadedFileDto: SetCurrentUploadedFileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'setCurrentUploadedFileDto' is not null or undefined
            assertParamExists('uploadedFilesControllerSetCurrentUploadedFile', 'setCurrentUploadedFileDto', setCurrentUploadedFileDto)
            const localVarPath = `/api/uploaded-files/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setCurrentUploadedFileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerStartStream: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/uploaded-files/stream/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerStopStream: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/uploaded-files/stream/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerUploadMultipleFiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/uploaded-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerUploadStreamChunk: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/uploaded-files/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadedFilesApi - functional programming interface
 * @export
 */
export const UploadedFilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadedFilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedFilesControllerGetCurrentFileForOrganization(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadedFileDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedFilesControllerGetCurrentFileForOrganization(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadedFilesApi.uploadedFilesControllerGetCurrentFileForOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedFilesControllerGetFilesForOrganization(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UploadedFileDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedFilesControllerGetFilesForOrganization(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadedFilesApi.uploadedFilesControllerGetFilesForOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedFilesControllerGetStreamManifest(organizationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedFilesControllerGetStreamManifest(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadedFilesApi.uploadedFilesControllerGetStreamManifest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedFilesControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedFilesControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadedFilesApi.uploadedFilesControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RenameUploadedFileDto} renameUploadedFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedFilesControllerRenameFile(renameUploadedFileDto: RenameUploadedFileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedFilesControllerRenameFile(renameUploadedFileDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadedFilesApi.uploadedFilesControllerRenameFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SetCurrentUploadedFileDto} setCurrentUploadedFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedFilesControllerSetCurrentUploadedFile(setCurrentUploadedFileDto: SetCurrentUploadedFileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedFilesControllerSetCurrentUploadedFile(setCurrentUploadedFileDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadedFilesApi.uploadedFilesControllerSetCurrentUploadedFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedFilesControllerStartStream(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedFilesControllerStartStream(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadedFilesApi.uploadedFilesControllerStartStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedFilesControllerStopStream(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedFilesControllerStopStream(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadedFilesApi.uploadedFilesControllerStopStream']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedFilesControllerUploadMultipleFiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedFilesControllerUploadMultipleFiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadedFilesApi.uploadedFilesControllerUploadMultipleFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadedFilesControllerUploadStreamChunk(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadedFilesControllerUploadStreamChunk(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadedFilesApi.uploadedFilesControllerUploadStreamChunk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadedFilesApi - factory interface
 * @export
 */
export const UploadedFilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadedFilesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerGetCurrentFileForOrganization(options?: any): AxiosPromise<UploadedFileDto> {
            return localVarFp.uploadedFilesControllerGetCurrentFileForOrganization(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerGetFilesForOrganization(options?: any): AxiosPromise<Array<UploadedFileDto>> {
            return localVarFp.uploadedFilesControllerGetFilesForOrganization(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerGetStreamManifest(organizationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.uploadedFilesControllerGetStreamManifest(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.uploadedFilesControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RenameUploadedFileDto} renameUploadedFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerRenameFile(renameUploadedFileDto: RenameUploadedFileDto, options?: any): AxiosPromise<void> {
            return localVarFp.uploadedFilesControllerRenameFile(renameUploadedFileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SetCurrentUploadedFileDto} setCurrentUploadedFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerSetCurrentUploadedFile(setCurrentUploadedFileDto: SetCurrentUploadedFileDto, options?: any): AxiosPromise<void> {
            return localVarFp.uploadedFilesControllerSetCurrentUploadedFile(setCurrentUploadedFileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerStartStream(options?: any): AxiosPromise<void> {
            return localVarFp.uploadedFilesControllerStartStream(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerStopStream(options?: any): AxiosPromise<void> {
            return localVarFp.uploadedFilesControllerStopStream(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerUploadMultipleFiles(options?: any): AxiosPromise<void> {
            return localVarFp.uploadedFilesControllerUploadMultipleFiles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadedFilesControllerUploadStreamChunk(options?: any): AxiosPromise<void> {
            return localVarFp.uploadedFilesControllerUploadStreamChunk(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadedFilesApi - object-oriented interface
 * @export
 * @class UploadedFilesApi
 * @extends {BaseAPI}
 */
export class UploadedFilesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadedFilesApi
     */
    public uploadedFilesControllerGetCurrentFileForOrganization(options?: RawAxiosRequestConfig) {
        return UploadedFilesApiFp(this.configuration).uploadedFilesControllerGetCurrentFileForOrganization(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadedFilesApi
     */
    public uploadedFilesControllerGetFilesForOrganization(options?: RawAxiosRequestConfig) {
        return UploadedFilesApiFp(this.configuration).uploadedFilesControllerGetFilesForOrganization(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadedFilesApi
     */
    public uploadedFilesControllerGetStreamManifest(organizationId: string, options?: RawAxiosRequestConfig) {
        return UploadedFilesApiFp(this.configuration).uploadedFilesControllerGetStreamManifest(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadedFilesApi
     */
    public uploadedFilesControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return UploadedFilesApiFp(this.configuration).uploadedFilesControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RenameUploadedFileDto} renameUploadedFileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadedFilesApi
     */
    public uploadedFilesControllerRenameFile(renameUploadedFileDto: RenameUploadedFileDto, options?: RawAxiosRequestConfig) {
        return UploadedFilesApiFp(this.configuration).uploadedFilesControllerRenameFile(renameUploadedFileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SetCurrentUploadedFileDto} setCurrentUploadedFileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadedFilesApi
     */
    public uploadedFilesControllerSetCurrentUploadedFile(setCurrentUploadedFileDto: SetCurrentUploadedFileDto, options?: RawAxiosRequestConfig) {
        return UploadedFilesApiFp(this.configuration).uploadedFilesControllerSetCurrentUploadedFile(setCurrentUploadedFileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadedFilesApi
     */
    public uploadedFilesControllerStartStream(options?: RawAxiosRequestConfig) {
        return UploadedFilesApiFp(this.configuration).uploadedFilesControllerStartStream(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadedFilesApi
     */
    public uploadedFilesControllerStopStream(options?: RawAxiosRequestConfig) {
        return UploadedFilesApiFp(this.configuration).uploadedFilesControllerStopStream(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadedFilesApi
     */
    public uploadedFilesControllerUploadMultipleFiles(options?: RawAxiosRequestConfig) {
        return UploadedFilesApiFp(this.configuration).uploadedFilesControllerUploadMultipleFiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadedFilesApi
     */
    public uploadedFilesControllerUploadStreamChunk(options?: RawAxiosRequestConfig) {
        return UploadedFilesApiFp(this.configuration).uploadedFilesControllerUploadStreamChunk(options).then((request) => request(this.axios, this.basePath));
    }
}



