/* tslint:disable */
/* eslint-disable */
/**
 * Projector
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CreateDisplayQueueDto
 */
export interface CreateDisplayQueueDto {
    /**
     * 
     * @type {string}
     * @memberof CreateDisplayQueueDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateDisplayQueueDto
     */
    'description'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateDisplayQueueDto
     */
    'textUnitIds': Array<number>;
}
/**
 * 
 * @export
 * @interface CreateOrganizationDto
 */
export interface CreateOrganizationDto {
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'paymentData': string;
    /**
     * 
     * @type {string}
     * @memberof CreateOrganizationDto
     */
    'contactData': string;
}
/**
 * 
 * @export
 * @interface CreateTextUnitDto
 */
export interface CreateTextUnitDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTextUnitDto
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTextUnitDto
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTextUnitDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateTextUnitDto
     */
    'transposition'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateTextUnitDto
     */
    'textUnitTagIds': Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof CreateTextUnitDto
     */
    'displayQueueIds': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof CreateTextUnitDto
     */
    'partsOrder'?: string;
}
/**
 * 
 * @export
 * @interface CreateTextUnitTagDto
 */
export interface CreateTextUnitTagDto {
    /**
     * 
     * @type {string}
     * @memberof CreateTextUnitTagDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTextUnitTagDto
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface CreateUserDto
 */
export interface CreateUserDto {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'password': string;
    /**
     * 
     * @type {number}
     * @memberof CreateUserDto
     */
    'organizationId': number;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDto
     */
    'role': CreateUserDtoRoleEnum;
}

export const CreateUserDtoRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type CreateUserDtoRoleEnum = typeof CreateUserDtoRoleEnum[keyof typeof CreateUserDtoRoleEnum];

/**
 * 
 * @export
 * @interface ExportWebRtcScreenDto
 */
export interface ExportWebRtcScreenDto {
    /**
     * 
     * @type {string}
     * @memberof ExportWebRtcScreenDto
     */
    'screenId': string;
}
/**
 * 
 * @export
 * @interface GetDisplayDto
 */
export interface GetDisplayDto {
    /**
     * 
     * @type {string}
     * @memberof GetDisplayDto
     */
    'displayType': GetDisplayDtoDisplayTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GetDisplayDto
     */
    'emptyDisplay': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetDisplayDto
     */
    'lines'?: Array<string>;
    /**
     * 
     * @type {GetMediaFileDto}
     * @memberof GetDisplayDto
     */
    'mediaFile'?: GetMediaFileDto;
    /**
     * 
     * @type {Array<WebRtcConnectionStructure>}
     * @memberof GetDisplayDto
     */
    'webRtcState'?: Array<WebRtcConnectionStructure>;
}

export const GetDisplayDtoDisplayTypeEnum = {
    Text: 'TEXT',
    Media: 'MEDIA',
    WebRtc: 'WEB_RTC'
} as const;

export type GetDisplayDtoDisplayTypeEnum = typeof GetDisplayDtoDisplayTypeEnum[keyof typeof GetDisplayDtoDisplayTypeEnum];

/**
 * 
 * @export
 * @interface GetDisplayQueueDto
 */
export interface GetDisplayQueueDto {
    /**
     * 
     * @type {number}
     * @memberof GetDisplayQueueDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetDisplayQueueDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDisplayQueueDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDisplayQueueDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetDisplayQueueDto
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof GetDisplayQueueDto
     */
    'organizationId'?: number;
    /**
     * 
     * @type {Array<GetQueueTextUnit>}
     * @memberof GetDisplayQueueDto
     */
    'queueTextUnits': Array<GetQueueTextUnit>;
}
/**
 * 
 * @export
 * @interface GetDisplayStateDto
 */
export interface GetDisplayStateDto {
    /**
     * 
     * @type {number}
     * @memberof GetDisplayStateDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetDisplayStateDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDisplayStateDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDisplayStateDto
     */
    'displayType': GetDisplayStateDtoDisplayTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GetDisplayStateDto
     */
    'emptyDisplay': boolean;
    /**
     * 
     * @type {number}
     * @memberof GetDisplayStateDto
     */
    'textUnitId': number;
    /**
     * 
     * @type {number}
     * @memberof GetDisplayStateDto
     */
    'textUnitPart': number;
    /**
     * 
     * @type {number}
     * @memberof GetDisplayStateDto
     */
    'textUnitPartPage': number;
    /**
     * 
     * @type {number}
     * @memberof GetDisplayStateDto
     */
    'mediaFileId': number | null;
    /**
     * 
     * @type {number}
     * @memberof GetDisplayStateDto
     */
    'textUnitQueueId': number;
}

export const GetDisplayStateDtoDisplayTypeEnum = {
    Text: 'TEXT',
    Media: 'MEDIA',
    WebRtc: 'WEB_RTC'
} as const;

export type GetDisplayStateDtoDisplayTypeEnum = typeof GetDisplayStateDtoDisplayTypeEnum[keyof typeof GetDisplayStateDtoDisplayTypeEnum];

/**
 * 
 * @export
 * @interface GetMediaFileDto
 */
export interface GetMediaFileDto {
    /**
     * 
     * @type {number}
     * @memberof GetMediaFileDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetMediaFileDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMediaFileDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMediaFileDto
     */
    'mimeType': string;
    /**
     * 
     * @type {string}
     * @memberof GetMediaFileDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetMediaFileDto
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof GetMediaFileDto
     */
    'size': number;
}
/**
 * 
 * @export
 * @interface GetProjectorSettingsDto
 */
export interface GetProjectorSettingsDto {
    /**
     * 
     * @type {number}
     * @memberof GetProjectorSettingsDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'backgroundColor': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'fontColor': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'fontFamily': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'fontSize': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'textAlign': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'letterSpacing': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'marginInline': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'marginBlock': string;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'paddingTop': string;
    /**
     * 
     * @type {number}
     * @memberof GetProjectorSettingsDto
     */
    'charactersInLine': number;
    /**
     * 
     * @type {number}
     * @memberof GetProjectorSettingsDto
     */
    'linesOnPage': number;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'textVertically': string;
    /**
     * 
     * @type {number}
     * @memberof GetProjectorSettingsDto
     */
    'screenWidth': number;
    /**
     * 
     * @type {number}
     * @memberof GetProjectorSettingsDto
     */
    'screenHeight': number;
    /**
     * 
     * @type {string}
     * @memberof GetProjectorSettingsDto
     */
    'lineHeight': string;
    /**
     * 
     * @type {TextStrategy}
     * @memberof GetProjectorSettingsDto
     */
    'textStrategy': TextStrategy;
}


/**
 * 
 * @export
 * @interface GetQueueTextUnit
 */
export interface GetQueueTextUnit {
    /**
     * 
     * @type {number}
     * @memberof GetQueueTextUnit
     */
    'id': number;
    /**
     * 
     * @type {number}
     * @memberof GetQueueTextUnit
     */
    'displayQueueId': number;
    /**
     * 
     * @type {number}
     * @memberof GetQueueTextUnit
     */
    'textUnitId': number;
    /**
     * 
     * @type {string}
     * @memberof GetQueueTextUnit
     */
    'textTitle': string;
    /**
     * 
     * @type {string}
     * @memberof GetQueueTextUnit
     */
    'queueName': string;
    /**
     * 
     * @type {number}
     * @memberof GetQueueTextUnit
     */
    'position': number;
}
/**
 * 
 * @export
 * @interface GetTextUnitDto
 */
export interface GetTextUnitDto {
    /**
     * 
     * @type {number}
     * @memberof GetTextUnitDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetTextUnitDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTextUnitDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTextUnitDto
     */
    'content': string;
    /**
     * 
     * @type {string}
     * @memberof GetTextUnitDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof GetTextUnitDto
     */
    'transposition'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTextUnitDto
     */
    'organizationId'?: number;
    /**
     * 
     * @type {string}
     * @memberof GetTextUnitDto
     */
    'title': string;
    /**
     * 
     * @type {Array<GetTextUnitTagDto>}
     * @memberof GetTextUnitDto
     */
    'tags': Array<GetTextUnitTagDto>;
    /**
     * 
     * @type {Array<GetQueueTextUnit>}
     * @memberof GetTextUnitDto
     */
    'queues': Array<GetQueueTextUnit>;
    /**
     * 
     * @type {string}
     * @memberof GetTextUnitDto
     */
    'partsOrder'?: string;
}
/**
 * 
 * @export
 * @interface GetTextUnitTagDto
 */
export interface GetTextUnitTagDto {
    /**
     * 
     * @type {number}
     * @memberof GetTextUnitTagDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof GetTextUnitTagDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTextUnitTagDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTextUnitTagDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetTextUnitTagDto
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof GetTextUnitTagDto
     */
    'organizationId'?: number;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface MovePageDto
 */
export interface MovePageDto {
    /**
     * 
     * @type {string}
     * @memberof MovePageDto
     */
    'direction': MovePageDtoDirectionEnum;
}

export const MovePageDtoDirectionEnum = {
    Next: 'NEXT',
    Previous: 'PREVIOUS'
} as const;

export type MovePageDtoDirectionEnum = typeof MovePageDtoDirectionEnum[keyof typeof MovePageDtoDirectionEnum];

/**
 * 
 * @export
 * @interface Organization
 */
export interface Organization {
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'paymentData': string;
    /**
     * 
     * @type {string}
     * @memberof Organization
     */
    'contactData': string;
    /**
     * 
     * @type {Array<User>}
     * @memberof Organization
     */
    'users': Array<User>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TextStrategy = {
    FixedLines: 'FIXED_LINES',
    Automatic: 'AUTOMATIC',
    ExampleText: 'EXAMPLE_TEXT'
} as const;

export type TextStrategy = typeof TextStrategy[keyof typeof TextStrategy];


/**
 * 
 * @export
 * @interface UpdateDisplayQueueDto
 */
export interface UpdateDisplayQueueDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateDisplayQueueDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDisplayQueueDto
     */
    'description'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateDisplayQueueDto
     */
    'textUnitIds'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof UpdateDisplayQueueDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface UpdateDisplayStateDto
 */
export interface UpdateDisplayStateDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateDisplayStateDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateDisplayStateDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDisplayStateDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateDisplayStateDto
     */
    'displayType'?: UpdateDisplayStateDtoDisplayTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateDisplayStateDto
     */
    'emptyDisplay'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateDisplayStateDto
     */
    'textUnitId'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateDisplayStateDto
     */
    'textUnitPart'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateDisplayStateDto
     */
    'textUnitPartPage'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateDisplayStateDto
     */
    'mediaFileId'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UpdateDisplayStateDto
     */
    'textUnitQueueId'?: number;
}

export const UpdateDisplayStateDtoDisplayTypeEnum = {
    Text: 'TEXT',
    Media: 'MEDIA',
    WebRtc: 'WEB_RTC'
} as const;

export type UpdateDisplayStateDtoDisplayTypeEnum = typeof UpdateDisplayStateDtoDisplayTypeEnum[keyof typeof UpdateDisplayStateDtoDisplayTypeEnum];

/**
 * 
 * @export
 * @interface UpdateMediaFileDto
 */
export interface UpdateMediaFileDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateMediaFileDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaFileDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateProjectorSettingDto
 */
export interface UpdateProjectorSettingDto {
    /**
     * 
     * @type {number}
     * @memberof UpdateProjectorSettingDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'backgroundColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'fontColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'fontFamily'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'fontSize'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'textAlign'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'letterSpacing'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'marginInline'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'marginBlock'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'paddingTop'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateProjectorSettingDto
     */
    'charactersInLine'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateProjectorSettingDto
     */
    'linesOnPage'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'textVertically'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateProjectorSettingDto
     */
    'screenWidth'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateProjectorSettingDto
     */
    'screenHeight'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateProjectorSettingDto
     */
    'lineHeight'?: string;
    /**
     * 
     * @type {TextStrategy}
     * @memberof UpdateProjectorSettingDto
     */
    'textStrategy'?: TextStrategy;
}


/**
 * 
 * @export
 * @interface UpdateTextUnitDto
 */
export interface UpdateTextUnitDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTextUnitDto
     */
    'content'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTextUnitDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTextUnitDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateTextUnitDto
     */
    'transposition'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateTextUnitDto
     */
    'textUnitTagIds'?: Array<number>;
    /**
     * 
     * @type {Array<number>}
     * @memberof UpdateTextUnitDto
     */
    'displayQueueIds'?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof UpdateTextUnitDto
     */
    'partsOrder'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateTextUnitDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface UpdateTextUnitTagDto
 */
export interface UpdateTextUnitTagDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateTextUnitTagDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTextUnitTagDto
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateTextUnitTagDto
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface UpdateUserDto
 */
export interface UpdateUserDto {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'password'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateUserDto
     */
    'organizationId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDto
     */
    'role'?: UpdateUserDtoRoleEnum;
    /**
     * 
     * @type {number}
     * @memberof UpdateUserDto
     */
    'id': number;
}

export const UpdateUserDtoRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UpdateUserDtoRoleEnum = typeof UpdateUserDtoRoleEnum[keyof typeof UpdateUserDtoRoleEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role': UserRoleEnum;
    /**
     * 
     * @type {Organization}
     * @memberof User
     */
    'organization': Organization | null;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'organizationId': number | null;
}

export const UserRoleEnum = {
    Admin: 'ADMIN',
    User: 'USER'
} as const;

export type UserRoleEnum = typeof UserRoleEnum[keyof typeof UserRoleEnum];

/**
 * 
 * @export
 * @interface WebRtcConnectionStructure
 */
export interface WebRtcConnectionStructure {
    /**
     * 
     * @type {object}
     * @memberof WebRtcConnectionStructure
     */
    'offer': object;
    /**
     * 
     * @type {object}
     * @memberof WebRtcConnectionStructure
     */
    'answer': object;
    /**
     * 
     * @type {string}
     * @memberof WebRtcConnectionStructure
     */
    'screenId': string;
}
/**
 * 
 * @export
 * @interface WebRtcSdpDto
 */
export interface WebRtcSdpDto {
    /**
     * 
     * @type {object}
     * @memberof WebRtcSdpDto
     */
    'payload': object;
    /**
     * 
     * @type {string}
     * @memberof WebRtcSdpDto
     */
    'screenId': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: any): AxiosPromise<string> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authControllerLogin(loginDto: LoginDto, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DisplayStateApi - axios parameter creator
 * @export
 */
export const DisplayStateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerCreateDisplayState: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/display-state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerGetDisplayState: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/display-state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MovePageDto} movePageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerMovePage: async (movePageDto: MovePageDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'movePageDto' is not null or undefined
            assertParamExists('displayStateControllerMovePage', 'movePageDto', movePageDto)
            const localVarPath = `/api/display-state/move-page`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(movePageDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateDisplayStateDto} updateDisplayStateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerUpdateDisplayState: async (updateDisplayStateDto: UpdateDisplayStateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDisplayStateDto' is not null or undefined
            assertParamExists('displayStateControllerUpdateDisplayState', 'updateDisplayStateDto', updateDisplayStateDto)
            const localVarPath = `/api/display-state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDisplayStateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisplayStateApi - functional programming interface
 * @export
 */
export const DisplayStateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisplayStateApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayStateControllerCreateDisplayState(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDisplayStateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayStateControllerCreateDisplayState(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisplayStateApi.displayStateControllerCreateDisplayState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayStateControllerGetDisplayState(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDisplayStateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayStateControllerGetDisplayState(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisplayStateApi.displayStateControllerGetDisplayState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {MovePageDto} movePageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayStateControllerMovePage(movePageDto: MovePageDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDisplayStateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayStateControllerMovePage(movePageDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisplayStateApi.displayStateControllerMovePage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateDisplayStateDto} updateDisplayStateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayStateControllerUpdateDisplayState(updateDisplayStateDto: UpdateDisplayStateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDisplayStateDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayStateControllerUpdateDisplayState(updateDisplayStateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DisplayStateApi.displayStateControllerUpdateDisplayState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DisplayStateApi - factory interface
 * @export
 */
export const DisplayStateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisplayStateApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerCreateDisplayState(options?: any): AxiosPromise<GetDisplayStateDto> {
            return localVarFp.displayStateControllerCreateDisplayState(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerGetDisplayState(options?: any): AxiosPromise<GetDisplayStateDto> {
            return localVarFp.displayStateControllerGetDisplayState(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MovePageDto} movePageDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerMovePage(movePageDto: MovePageDto, options?: any): AxiosPromise<GetDisplayStateDto> {
            return localVarFp.displayStateControllerMovePage(movePageDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateDisplayStateDto} updateDisplayStateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayStateControllerUpdateDisplayState(updateDisplayStateDto: UpdateDisplayStateDto, options?: any): AxiosPromise<GetDisplayStateDto> {
            return localVarFp.displayStateControllerUpdateDisplayState(updateDisplayStateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisplayStateApi - object-oriented interface
 * @export
 * @class DisplayStateApi
 * @extends {BaseAPI}
 */
export class DisplayStateApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayStateApi
     */
    public displayStateControllerCreateDisplayState(options?: RawAxiosRequestConfig) {
        return DisplayStateApiFp(this.configuration).displayStateControllerCreateDisplayState(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayStateApi
     */
    public displayStateControllerGetDisplayState(options?: RawAxiosRequestConfig) {
        return DisplayStateApiFp(this.configuration).displayStateControllerGetDisplayState(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MovePageDto} movePageDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayStateApi
     */
    public displayStateControllerMovePage(movePageDto: MovePageDto, options?: RawAxiosRequestConfig) {
        return DisplayStateApiFp(this.configuration).displayStateControllerMovePage(movePageDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateDisplayStateDto} updateDisplayStateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisplayStateApi
     */
    public displayStateControllerUpdateDisplayState(updateDisplayStateDto: UpdateDisplayStateDto, options?: RawAxiosRequestConfig) {
        return DisplayStateApiFp(this.configuration).displayStateControllerUpdateDisplayState(updateDisplayStateDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaFilesApi - axios parameter creator
 * @export
 */
export const MediaFilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaFilesControllerGetFilesForOrganization: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/media-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaFilesControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mediaFilesControllerRemove', 'id', id)
            const localVarPath = `/api/media-files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateMediaFileDto} updateMediaFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaFilesControllerRenameFile: async (updateMediaFileDto: UpdateMediaFileDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateMediaFileDto' is not null or undefined
            assertParamExists('mediaFilesControllerRenameFile', 'updateMediaFileDto', updateMediaFileDto)
            const localVarPath = `/api/media-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMediaFileDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaFilesControllerUploadMultipleFiles: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/media-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaFilesApi - functional programming interface
 * @export
 */
export const MediaFilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaFilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaFilesControllerGetFilesForOrganization(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetMediaFileDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaFilesControllerGetFilesForOrganization(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaFilesApi.mediaFilesControllerGetFilesForOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaFilesControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaFilesControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaFilesApi.mediaFilesControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateMediaFileDto} updateMediaFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaFilesControllerRenameFile(updateMediaFileDto: UpdateMediaFileDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMediaFileDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaFilesControllerRenameFile(updateMediaFileDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaFilesApi.mediaFilesControllerRenameFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaFilesControllerUploadMultipleFiles(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaFilesControllerUploadMultipleFiles(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaFilesApi.mediaFilesControllerUploadMultipleFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaFilesApi - factory interface
 * @export
 */
export const MediaFilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaFilesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaFilesControllerGetFilesForOrganization(options?: any): AxiosPromise<Array<GetMediaFileDto>> {
            return localVarFp.mediaFilesControllerGetFilesForOrganization(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaFilesControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.mediaFilesControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateMediaFileDto} updateMediaFileDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaFilesControllerRenameFile(updateMediaFileDto: UpdateMediaFileDto, options?: any): AxiosPromise<GetMediaFileDto> {
            return localVarFp.mediaFilesControllerRenameFile(updateMediaFileDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaFilesControllerUploadMultipleFiles(options?: any): AxiosPromise<void> {
            return localVarFp.mediaFilesControllerUploadMultipleFiles(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaFilesApi - object-oriented interface
 * @export
 * @class MediaFilesApi
 * @extends {BaseAPI}
 */
export class MediaFilesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaFilesApi
     */
    public mediaFilesControllerGetFilesForOrganization(options?: RawAxiosRequestConfig) {
        return MediaFilesApiFp(this.configuration).mediaFilesControllerGetFilesForOrganization(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaFilesApi
     */
    public mediaFilesControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return MediaFilesApiFp(this.configuration).mediaFilesControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateMediaFileDto} updateMediaFileDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaFilesApi
     */
    public mediaFilesControllerRenameFile(updateMediaFileDto: UpdateMediaFileDto, options?: RawAxiosRequestConfig) {
        return MediaFilesApiFp(this.configuration).mediaFilesControllerRenameFile(updateMediaFileDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaFilesApi
     */
    public mediaFilesControllerUploadMultipleFiles(options?: RawAxiosRequestConfig) {
        return MediaFilesApiFp(this.configuration).mediaFilesControllerUploadMultipleFiles(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrganizationsApi - axios parameter creator
 * @export
 */
export const OrganizationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerCreateOrganization: async (createOrganizationDto: CreateOrganizationDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrganizationDto' is not null or undefined
            assertParamExists('organizationControllerCreateOrganization', 'createOrganizationDto', createOrganizationDto)
            const localVarPath = `/api/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrganizationDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerDeleteOrganization: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('organizationControllerDeleteOrganization', 'id', id)
            const localVarPath = `/api/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerGetOrganization: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('organizationControllerGetOrganization', 'id', id)
            const localVarPath = `/api/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerGetOrganizations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerUpdateOrganization: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('organizationControllerUpdateOrganization', 'updateUserDto', updateUserDto)
            const localVarPath = `/api/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationsApi - functional programming interface
 * @export
 */
export const OrganizationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrganizationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationControllerCreateOrganization(createOrganizationDto: CreateOrganizationDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationControllerCreateOrganization(createOrganizationDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.organizationControllerCreateOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationControllerDeleteOrganization(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationControllerDeleteOrganization(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.organizationControllerDeleteOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationControllerGetOrganization(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organization>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationControllerGetOrganization(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.organizationControllerGetOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationControllerGetOrganizations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organization>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationControllerGetOrganizations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.organizationControllerGetOrganizations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async organizationControllerUpdateOrganization(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.organizationControllerUpdateOrganization(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrganizationsApi.organizationControllerUpdateOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrganizationsApi - factory interface
 * @export
 */
export const OrganizationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrganizationsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateOrganizationDto} createOrganizationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerCreateOrganization(createOrganizationDto: CreateOrganizationDto, options?: any): AxiosPromise<Organization> {
            return localVarFp.organizationControllerCreateOrganization(createOrganizationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerDeleteOrganization(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.organizationControllerDeleteOrganization(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerGetOrganization(id: number, options?: any): AxiosPromise<Organization> {
            return localVarFp.organizationControllerGetOrganization(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerGetOrganizations(options?: any): AxiosPromise<Array<Organization>> {
            return localVarFp.organizationControllerGetOrganizations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        organizationControllerUpdateOrganization(updateUserDto: UpdateUserDto, options?: any): AxiosPromise<object> {
            return localVarFp.organizationControllerUpdateOrganization(updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrganizationsApi - object-oriented interface
 * @export
 * @class OrganizationsApi
 * @extends {BaseAPI}
 */
export class OrganizationsApi extends BaseAPI {
    /**
     * 
     * @param {CreateOrganizationDto} createOrganizationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationControllerCreateOrganization(createOrganizationDto: CreateOrganizationDto, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationControllerCreateOrganization(createOrganizationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationControllerDeleteOrganization(id: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationControllerDeleteOrganization(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationControllerGetOrganization(id: number, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationControllerGetOrganization(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationControllerGetOrganizations(options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationControllerGetOrganizations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationsApi
     */
    public organizationControllerUpdateOrganization(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return OrganizationsApiFp(this.configuration).organizationControllerUpdateOrganization(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectorApi - axios parameter creator
 * @export
 */
export const ProjectorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorControllerGetProjectorState: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projector`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorControllerGetProjectorStateByOrganizationId: async (organizationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('projectorControllerGetProjectorStateByOrganizationId', 'organizationId', organizationId)
            const localVarPath = `/api/projector/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectorApi - functional programming interface
 * @export
 */
export const ProjectorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectorControllerGetProjectorState(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDisplayDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectorControllerGetProjectorState(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectorApi.projectorControllerGetProjectorState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectorControllerGetProjectorStateByOrganizationId(organizationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDisplayDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectorControllerGetProjectorStateByOrganizationId(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectorApi.projectorControllerGetProjectorStateByOrganizationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectorApi - factory interface
 * @export
 */
export const ProjectorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectorApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorControllerGetProjectorState(options?: any): AxiosPromise<GetDisplayDto> {
            return localVarFp.projectorControllerGetProjectorState(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorControllerGetProjectorStateByOrganizationId(organizationId: number, options?: any): AxiosPromise<GetDisplayDto> {
            return localVarFp.projectorControllerGetProjectorStateByOrganizationId(organizationId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectorApi - object-oriented interface
 * @export
 * @class ProjectorApi
 * @extends {BaseAPI}
 */
export class ProjectorApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectorApi
     */
    public projectorControllerGetProjectorState(options?: RawAxiosRequestConfig) {
        return ProjectorApiFp(this.configuration).projectorControllerGetProjectorState(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectorApi
     */
    public projectorControllerGetProjectorStateByOrganizationId(organizationId: number, options?: RawAxiosRequestConfig) {
        return ProjectorApiFp(this.configuration).projectorControllerGetProjectorStateByOrganizationId(organizationId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectorSettingsApi - axios parameter creator
 * @export
 */
export const ProjectorSettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerCreateF: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projector-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerGetSetting: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/projector-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerGetSettingsByOrganizationId: async (organizationId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'organizationId' is not null or undefined
            assertParamExists('projectorSettingsControllerGetSettingsByOrganizationId', 'organizationId', organizationId)
            const localVarPath = `/api/projector-settings/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateProjectorSettingDto} updateProjectorSettingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerUpdate: async (updateProjectorSettingDto: UpdateProjectorSettingDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProjectorSettingDto' is not null or undefined
            assertParamExists('projectorSettingsControllerUpdate', 'updateProjectorSettingDto', updateProjectorSettingDto)
            const localVarPath = `/api/projector-settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProjectorSettingDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectorSettingsApi - functional programming interface
 * @export
 */
export const ProjectorSettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectorSettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectorSettingsControllerCreateF(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectorSettingsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectorSettingsControllerCreateF(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectorSettingsApi.projectorSettingsControllerCreateF']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectorSettingsControllerGetSetting(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectorSettingsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectorSettingsControllerGetSetting(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectorSettingsApi.projectorSettingsControllerGetSetting']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectorSettingsControllerGetSettingsByOrganizationId(organizationId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectorSettingsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectorSettingsControllerGetSettingsByOrganizationId(organizationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectorSettingsApi.projectorSettingsControllerGetSettingsByOrganizationId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateProjectorSettingDto} updateProjectorSettingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectorSettingsControllerUpdate(updateProjectorSettingDto: UpdateProjectorSettingDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetProjectorSettingsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectorSettingsControllerUpdate(updateProjectorSettingDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProjectorSettingsApi.projectorSettingsControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProjectorSettingsApi - factory interface
 * @export
 */
export const ProjectorSettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectorSettingsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerCreateF(options?: any): AxiosPromise<GetProjectorSettingsDto> {
            return localVarFp.projectorSettingsControllerCreateF(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerGetSetting(options?: any): AxiosPromise<GetProjectorSettingsDto> {
            return localVarFp.projectorSettingsControllerGetSetting(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerGetSettingsByOrganizationId(organizationId: number, options?: any): AxiosPromise<GetProjectorSettingsDto> {
            return localVarFp.projectorSettingsControllerGetSettingsByOrganizationId(organizationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateProjectorSettingDto} updateProjectorSettingDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectorSettingsControllerUpdate(updateProjectorSettingDto: UpdateProjectorSettingDto, options?: any): AxiosPromise<GetProjectorSettingsDto> {
            return localVarFp.projectorSettingsControllerUpdate(updateProjectorSettingDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectorSettingsApi - object-oriented interface
 * @export
 * @class ProjectorSettingsApi
 * @extends {BaseAPI}
 */
export class ProjectorSettingsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectorSettingsApi
     */
    public projectorSettingsControllerCreateF(options?: RawAxiosRequestConfig) {
        return ProjectorSettingsApiFp(this.configuration).projectorSettingsControllerCreateF(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectorSettingsApi
     */
    public projectorSettingsControllerGetSetting(options?: RawAxiosRequestConfig) {
        return ProjectorSettingsApiFp(this.configuration).projectorSettingsControllerGetSetting(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectorSettingsApi
     */
    public projectorSettingsControllerGetSettingsByOrganizationId(organizationId: number, options?: RawAxiosRequestConfig) {
        return ProjectorSettingsApiFp(this.configuration).projectorSettingsControllerGetSettingsByOrganizationId(organizationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateProjectorSettingDto} updateProjectorSettingDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectorSettingsApi
     */
    public projectorSettingsControllerUpdate(updateProjectorSettingDto: UpdateProjectorSettingDto, options?: RawAxiosRequestConfig) {
        return ProjectorSettingsApiFp(this.configuration).projectorSettingsControllerUpdate(updateProjectorSettingDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextUnitQueuesApi - axios parameter creator
 * @export
 */
export const TextUnitQueuesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateDisplayQueueDto} createDisplayQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayQueuesControllerCreate: async (createDisplayQueueDto: CreateDisplayQueueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createDisplayQueueDto' is not null or undefined
            assertParamExists('displayQueuesControllerCreate', 'createDisplayQueueDto', createDisplayQueueDto)
            const localVarPath = `/api/text-unit-queues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDisplayQueueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayQueuesControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/text-unit-queues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayQueuesControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('displayQueuesControllerFindOne', 'id', id)
            const localVarPath = `/api/text-unit-queues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayQueuesControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('displayQueuesControllerRemove', 'id', id)
            const localVarPath = `/api/text-unit-queues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateDisplayQueueDto} updateDisplayQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayQueuesControllerUpdate: async (updateDisplayQueueDto: UpdateDisplayQueueDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDisplayQueueDto' is not null or undefined
            assertParamExists('displayQueuesControllerUpdate', 'updateDisplayQueueDto', updateDisplayQueueDto)
            const localVarPath = `/api/text-unit-queues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDisplayQueueDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextUnitQueuesApi - functional programming interface
 * @export
 */
export const TextUnitQueuesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextUnitQueuesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateDisplayQueueDto} createDisplayQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayQueuesControllerCreate(createDisplayQueueDto: CreateDisplayQueueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDisplayQueueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayQueuesControllerCreate(createDisplayQueueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitQueuesApi.displayQueuesControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayQueuesControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetDisplayQueueDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayQueuesControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitQueuesApi.displayQueuesControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayQueuesControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDisplayQueueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayQueuesControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitQueuesApi.displayQueuesControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayQueuesControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayQueuesControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitQueuesApi.displayQueuesControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateDisplayQueueDto} updateDisplayQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async displayQueuesControllerUpdate(updateDisplayQueueDto: UpdateDisplayQueueDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDisplayQueueDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.displayQueuesControllerUpdate(updateDisplayQueueDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitQueuesApi.displayQueuesControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextUnitQueuesApi - factory interface
 * @export
 */
export const TextUnitQueuesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextUnitQueuesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateDisplayQueueDto} createDisplayQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayQueuesControllerCreate(createDisplayQueueDto: CreateDisplayQueueDto, options?: any): AxiosPromise<GetDisplayQueueDto> {
            return localVarFp.displayQueuesControllerCreate(createDisplayQueueDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayQueuesControllerFindAll(options?: any): AxiosPromise<Array<GetDisplayQueueDto>> {
            return localVarFp.displayQueuesControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayQueuesControllerFindOne(id: string, options?: any): AxiosPromise<GetDisplayQueueDto> {
            return localVarFp.displayQueuesControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayQueuesControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.displayQueuesControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateDisplayQueueDto} updateDisplayQueueDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        displayQueuesControllerUpdate(updateDisplayQueueDto: UpdateDisplayQueueDto, options?: any): AxiosPromise<GetDisplayQueueDto> {
            return localVarFp.displayQueuesControllerUpdate(updateDisplayQueueDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextUnitQueuesApi - object-oriented interface
 * @export
 * @class TextUnitQueuesApi
 * @extends {BaseAPI}
 */
export class TextUnitQueuesApi extends BaseAPI {
    /**
     * 
     * @param {CreateDisplayQueueDto} createDisplayQueueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitQueuesApi
     */
    public displayQueuesControllerCreate(createDisplayQueueDto: CreateDisplayQueueDto, options?: RawAxiosRequestConfig) {
        return TextUnitQueuesApiFp(this.configuration).displayQueuesControllerCreate(createDisplayQueueDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitQueuesApi
     */
    public displayQueuesControllerFindAll(options?: RawAxiosRequestConfig) {
        return TextUnitQueuesApiFp(this.configuration).displayQueuesControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitQueuesApi
     */
    public displayQueuesControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return TextUnitQueuesApiFp(this.configuration).displayQueuesControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitQueuesApi
     */
    public displayQueuesControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return TextUnitQueuesApiFp(this.configuration).displayQueuesControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateDisplayQueueDto} updateDisplayQueueDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitQueuesApi
     */
    public displayQueuesControllerUpdate(updateDisplayQueueDto: UpdateDisplayQueueDto, options?: RawAxiosRequestConfig) {
        return TextUnitQueuesApiFp(this.configuration).displayQueuesControllerUpdate(updateDisplayQueueDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextUnitTagApi - axios parameter creator
 * @export
 */
export const TextUnitTagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTextUnitTagDto} createTextUnitTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerCreate: async (createTextUnitTagDto: CreateTextUnitTagDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTextUnitTagDto' is not null or undefined
            assertParamExists('textUnitTagControllerCreate', 'createTextUnitTagDto', createTextUnitTagDto)
            const localVarPath = `/api/text-unit-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTextUnitTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/text-unit-tag`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textUnitTagControllerFindOne', 'id', id)
            const localVarPath = `/api/text-unit-tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textUnitTagControllerRemove', 'id', id)
            const localVarPath = `/api/text-unit-tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTextUnitTagDto} updateTextUnitTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerUpdate: async (id: string, updateTextUnitTagDto: UpdateTextUnitTagDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textUnitTagControllerUpdate', 'id', id)
            // verify required parameter 'updateTextUnitTagDto' is not null or undefined
            assertParamExists('textUnitTagControllerUpdate', 'updateTextUnitTagDto', updateTextUnitTagDto)
            const localVarPath = `/api/text-unit-tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTextUnitTagDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextUnitTagApi - functional programming interface
 * @export
 */
export const TextUnitTagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextUnitTagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTextUnitTagDto} createTextUnitTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitTagControllerCreate(createTextUnitTagDto: CreateTextUnitTagDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTextUnitTagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitTagControllerCreate(createTextUnitTagDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitTagApi.textUnitTagControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitTagControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTextUnitTagDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitTagControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitTagApi.textUnitTagControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitTagControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTextUnitTagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitTagControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitTagApi.textUnitTagControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitTagControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitTagControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitTagApi.textUnitTagControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTextUnitTagDto} updateTextUnitTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitTagControllerUpdate(id: string, updateTextUnitTagDto: UpdateTextUnitTagDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTextUnitTagDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitTagControllerUpdate(id, updateTextUnitTagDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitTagApi.textUnitTagControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextUnitTagApi - factory interface
 * @export
 */
export const TextUnitTagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextUnitTagApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTextUnitTagDto} createTextUnitTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerCreate(createTextUnitTagDto: CreateTextUnitTagDto, options?: any): AxiosPromise<GetTextUnitTagDto> {
            return localVarFp.textUnitTagControllerCreate(createTextUnitTagDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerFindAll(options?: any): AxiosPromise<Array<GetTextUnitTagDto>> {
            return localVarFp.textUnitTagControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerFindOne(id: string, options?: any): AxiosPromise<GetTextUnitTagDto> {
            return localVarFp.textUnitTagControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.textUnitTagControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateTextUnitTagDto} updateTextUnitTagDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitTagControllerUpdate(id: string, updateTextUnitTagDto: UpdateTextUnitTagDto, options?: any): AxiosPromise<GetTextUnitTagDto> {
            return localVarFp.textUnitTagControllerUpdate(id, updateTextUnitTagDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextUnitTagApi - object-oriented interface
 * @export
 * @class TextUnitTagApi
 * @extends {BaseAPI}
 */
export class TextUnitTagApi extends BaseAPI {
    /**
     * 
     * @param {CreateTextUnitTagDto} createTextUnitTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitTagApi
     */
    public textUnitTagControllerCreate(createTextUnitTagDto: CreateTextUnitTagDto, options?: RawAxiosRequestConfig) {
        return TextUnitTagApiFp(this.configuration).textUnitTagControllerCreate(createTextUnitTagDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitTagApi
     */
    public textUnitTagControllerFindAll(options?: RawAxiosRequestConfig) {
        return TextUnitTagApiFp(this.configuration).textUnitTagControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitTagApi
     */
    public textUnitTagControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return TextUnitTagApiFp(this.configuration).textUnitTagControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitTagApi
     */
    public textUnitTagControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return TextUnitTagApiFp(this.configuration).textUnitTagControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateTextUnitTagDto} updateTextUnitTagDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitTagApi
     */
    public textUnitTagControllerUpdate(id: string, updateTextUnitTagDto: UpdateTextUnitTagDto, options?: RawAxiosRequestConfig) {
        return TextUnitTagApiFp(this.configuration).textUnitTagControllerUpdate(id, updateTextUnitTagDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextUnitsApi - axios parameter creator
 * @export
 */
export const TextUnitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateTextUnitDto} createTextUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerCreate: async (createTextUnitDto: CreateTextUnitDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTextUnitDto' is not null or undefined
            assertParamExists('textUnitControllerCreate', 'createTextUnitDto', createTextUnitDto)
            const localVarPath = `/api/text-units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTextUnitDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerFindAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/text-units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textUnitControllerFindOne', 'id', id)
            const localVarPath = `/api/text-units/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('textUnitControllerRemove', 'id', id)
            const localVarPath = `/api/text-units/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateTextUnitDto} updateTextUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerUpdate: async (updateTextUnitDto: UpdateTextUnitDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateTextUnitDto' is not null or undefined
            assertParamExists('textUnitControllerUpdate', 'updateTextUnitDto', updateTextUnitDto)
            const localVarPath = `/api/text-units`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTextUnitDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextUnitsApi - functional programming interface
 * @export
 */
export const TextUnitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextUnitsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateTextUnitDto} createTextUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitControllerCreate(createTextUnitDto: CreateTextUnitDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitControllerCreate(createTextUnitDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitsApi.textUnitControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitControllerFindAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetTextUnitDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitControllerFindAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitsApi.textUnitControllerFindAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTextUnitDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitsApi.textUnitControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitsApi.textUnitControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateTextUnitDto} updateTextUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async textUnitControllerUpdate(updateTextUnitDto: UpdateTextUnitDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.textUnitControllerUpdate(updateTextUnitDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextUnitsApi.textUnitControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextUnitsApi - factory interface
 * @export
 */
export const TextUnitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextUnitsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateTextUnitDto} createTextUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerCreate(createTextUnitDto: CreateTextUnitDto, options?: any): AxiosPromise<void> {
            return localVarFp.textUnitControllerCreate(createTextUnitDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerFindAll(options?: any): AxiosPromise<Array<GetTextUnitDto>> {
            return localVarFp.textUnitControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerFindOne(id: string, options?: any): AxiosPromise<GetTextUnitDto> {
            return localVarFp.textUnitControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.textUnitControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateTextUnitDto} updateTextUnitDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        textUnitControllerUpdate(updateTextUnitDto: UpdateTextUnitDto, options?: any): AxiosPromise<void> {
            return localVarFp.textUnitControllerUpdate(updateTextUnitDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextUnitsApi - object-oriented interface
 * @export
 * @class TextUnitsApi
 * @extends {BaseAPI}
 */
export class TextUnitsApi extends BaseAPI {
    /**
     * 
     * @param {CreateTextUnitDto} createTextUnitDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitsApi
     */
    public textUnitControllerCreate(createTextUnitDto: CreateTextUnitDto, options?: RawAxiosRequestConfig) {
        return TextUnitsApiFp(this.configuration).textUnitControllerCreate(createTextUnitDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitsApi
     */
    public textUnitControllerFindAll(options?: RawAxiosRequestConfig) {
        return TextUnitsApiFp(this.configuration).textUnitControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitsApi
     */
    public textUnitControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return TextUnitsApiFp(this.configuration).textUnitControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitsApi
     */
    public textUnitControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return TextUnitsApiFp(this.configuration).textUnitControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateTextUnitDto} updateTextUnitDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextUnitsApi
     */
    public textUnitControllerUpdate(updateTextUnitDto: UpdateTextUnitDto, options?: RawAxiosRequestConfig) {
        return TextUnitsApiFp(this.configuration).textUnitControllerUpdate(updateTextUnitDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreateUser: async (createUserDto: CreateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDto' is not null or undefined
            assertParamExists('userControllerCreateUser', 'createUserDto', createUserDto)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeleteUser: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerDeleteUser', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUser: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerGetUser', 'id', id)
            const localVarPath = `/api/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateUser: async (updateUserDto: UpdateUserDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserDto' is not null or undefined
            assertParamExists('userControllerUpdateUser', 'updateUserDto', updateUserDto)
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerCreateUser(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerCreateUser(createUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerCreateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerDeleteUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerDeleteUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerDeleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerGetUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdateUser(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdateUser(updateUserDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.userControllerUpdateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateUserDto} createUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreateUser(createUserDto: CreateUserDto, options?: any): AxiosPromise<User> {
            return localVarFp.userControllerCreateUser(createUserDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeleteUser(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userControllerDeleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUser(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.userControllerGetUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetUsers(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userControllerGetUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserDto} updateUserDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdateUser(updateUserDto: UpdateUserDto, options?: any): AxiosPromise<object> {
            return localVarFp.userControllerUpdateUser(updateUserDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {CreateUserDto} createUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerCreateUser(createUserDto: CreateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerCreateUser(createUserDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerDeleteUser(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerDeleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetUser(id: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerGetUsers(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerGetUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserDto} updateUserDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public userControllerUpdateUser(updateUserDto: UpdateUserDto, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).userControllerUpdateUser(updateUserDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebrtcStreamApi - axios parameter creator
 * @export
 */
export const WebrtcStreamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webRtcControllerClearOrganization: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webrtc-stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webRtcControllerGetState: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/webrtc-stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportWebRtcScreenDto} exportWebRtcScreenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webRtcControllerRemoveScreen: async (exportWebRtcScreenDto: ExportWebRtcScreenDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportWebRtcScreenDto' is not null or undefined
            assertParamExists('webRtcControllerRemoveScreen', 'exportWebRtcScreenDto', exportWebRtcScreenDto)
            const localVarPath = `/api/webrtc-stream/screen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportWebRtcScreenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WebRtcSdpDto} webRtcSdpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webRtcControllerSetAnswer: async (webRtcSdpDto: WebRtcSdpDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webRtcSdpDto' is not null or undefined
            assertParamExists('webRtcControllerSetAnswer', 'webRtcSdpDto', webRtcSdpDto)
            const localVarPath = `/api/webrtc-stream/answer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webRtcSdpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WebRtcSdpDto} webRtcSdpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webRtcControllerSetOffer: async (webRtcSdpDto: WebRtcSdpDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'webRtcSdpDto' is not null or undefined
            assertParamExists('webRtcControllerSetOffer', 'webRtcSdpDto', webRtcSdpDto)
            const localVarPath = `/api/webrtc-stream/offer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(webRtcSdpDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportWebRtcScreenDto} exportWebRtcScreenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webRtcControllerSetScreen: async (exportWebRtcScreenDto: ExportWebRtcScreenDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportWebRtcScreenDto' is not null or undefined
            assertParamExists('webRtcControllerSetScreen', 'exportWebRtcScreenDto', exportWebRtcScreenDto)
            const localVarPath = `/api/webrtc-stream/screen`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportWebRtcScreenDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebrtcStreamApi - functional programming interface
 * @export
 */
export const WebrtcStreamApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebrtcStreamApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webRtcControllerClearOrganization(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webRtcControllerClearOrganization(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebrtcStreamApi.webRtcControllerClearOrganization']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webRtcControllerGetState(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webRtcControllerGetState(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebrtcStreamApi.webRtcControllerGetState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ExportWebRtcScreenDto} exportWebRtcScreenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webRtcControllerRemoveScreen(exportWebRtcScreenDto: ExportWebRtcScreenDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webRtcControllerRemoveScreen(exportWebRtcScreenDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebrtcStreamApi.webRtcControllerRemoveScreen']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {WebRtcSdpDto} webRtcSdpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webRtcControllerSetAnswer(webRtcSdpDto: WebRtcSdpDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webRtcControllerSetAnswer(webRtcSdpDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebrtcStreamApi.webRtcControllerSetAnswer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {WebRtcSdpDto} webRtcSdpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webRtcControllerSetOffer(webRtcSdpDto: WebRtcSdpDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webRtcControllerSetOffer(webRtcSdpDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebrtcStreamApi.webRtcControllerSetOffer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ExportWebRtcScreenDto} exportWebRtcScreenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webRtcControllerSetScreen(exportWebRtcScreenDto: ExportWebRtcScreenDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webRtcControllerSetScreen(exportWebRtcScreenDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebrtcStreamApi.webRtcControllerSetScreen']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebrtcStreamApi - factory interface
 * @export
 */
export const WebrtcStreamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebrtcStreamApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webRtcControllerClearOrganization(options?: any): AxiosPromise<void> {
            return localVarFp.webRtcControllerClearOrganization(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webRtcControllerGetState(options?: any): AxiosPromise<void> {
            return localVarFp.webRtcControllerGetState(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportWebRtcScreenDto} exportWebRtcScreenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webRtcControllerRemoveScreen(exportWebRtcScreenDto: ExportWebRtcScreenDto, options?: any): AxiosPromise<void> {
            return localVarFp.webRtcControllerRemoveScreen(exportWebRtcScreenDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WebRtcSdpDto} webRtcSdpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webRtcControllerSetAnswer(webRtcSdpDto: WebRtcSdpDto, options?: any): AxiosPromise<void> {
            return localVarFp.webRtcControllerSetAnswer(webRtcSdpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WebRtcSdpDto} webRtcSdpDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webRtcControllerSetOffer(webRtcSdpDto: WebRtcSdpDto, options?: any): AxiosPromise<void> {
            return localVarFp.webRtcControllerSetOffer(webRtcSdpDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportWebRtcScreenDto} exportWebRtcScreenDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webRtcControllerSetScreen(exportWebRtcScreenDto: ExportWebRtcScreenDto, options?: any): AxiosPromise<void> {
            return localVarFp.webRtcControllerSetScreen(exportWebRtcScreenDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebrtcStreamApi - object-oriented interface
 * @export
 * @class WebrtcStreamApi
 * @extends {BaseAPI}
 */
export class WebrtcStreamApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcStreamApi
     */
    public webRtcControllerClearOrganization(options?: RawAxiosRequestConfig) {
        return WebrtcStreamApiFp(this.configuration).webRtcControllerClearOrganization(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcStreamApi
     */
    public webRtcControllerGetState(options?: RawAxiosRequestConfig) {
        return WebrtcStreamApiFp(this.configuration).webRtcControllerGetState(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExportWebRtcScreenDto} exportWebRtcScreenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcStreamApi
     */
    public webRtcControllerRemoveScreen(exportWebRtcScreenDto: ExportWebRtcScreenDto, options?: RawAxiosRequestConfig) {
        return WebrtcStreamApiFp(this.configuration).webRtcControllerRemoveScreen(exportWebRtcScreenDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WebRtcSdpDto} webRtcSdpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcStreamApi
     */
    public webRtcControllerSetAnswer(webRtcSdpDto: WebRtcSdpDto, options?: RawAxiosRequestConfig) {
        return WebrtcStreamApiFp(this.configuration).webRtcControllerSetAnswer(webRtcSdpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WebRtcSdpDto} webRtcSdpDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcStreamApi
     */
    public webRtcControllerSetOffer(webRtcSdpDto: WebRtcSdpDto, options?: RawAxiosRequestConfig) {
        return WebrtcStreamApiFp(this.configuration).webRtcControllerSetOffer(webRtcSdpDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExportWebRtcScreenDto} exportWebRtcScreenDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebrtcStreamApi
     */
    public webRtcControllerSetScreen(exportWebRtcScreenDto: ExportWebRtcScreenDto, options?: RawAxiosRequestConfig) {
        return WebrtcStreamApiFp(this.configuration).webRtcControllerSetScreen(exportWebRtcScreenDto, options).then((request) => request(this.axios, this.basePath));
    }
}



